// Test generated by RoostGPT for test nodeJsTest1 using AI Type Azure Open AI and AI Model roost-gpt4-32k

import { processResponse } from './postmanCollectionProcessor';

// mock logger as it's an external dependency
jest.mock('../utils/logUtility', () => ({
  logger: {
    error: jest.fn()
  }
}));

describe('processResponse', () => {
  let responseNode;

  beforeEach(() => {
    // reset the responseNode before each test
    responseNode = {
      header: [],
      body: []
    };
  });

  it('should add a variable if the header value does not start and end with {{ and }}', async () => {
    const header = {
      key: 'testHeader',
      value: 'testValue'
    };
    responseNode.header.push(header);

    const result = await processResponse(responseNode);
    const variableName = `{{res_${header.key}}}`;

    expect(result.header[0].value).toEqual(variableName);
    // assuming addVariable function is globally defined. If it's not, you'll need to stub/mocks it with jest.fn
    expect(addVariable).toHaveBeenCalledWith(variableName);
  });

  it('should log an error if parsing the raw body throws an error', async () => {
    const body = {
      raw: 'this should cause an error'
    };
    responseNode.body.push(body);

    await processResponse(responseNode);

    expect(logger.error).toHaveBeenCalledWith('Error parsing raw body:', expect.any(String), body.raw);
  });

  it('should transform values in the body if they are strings and do not start and end with {{ and }}', async () => {
    const jsonBody = {
      key1: 'value1',
      key2: 'value2'
    };
    const body = {
      raw: JSON.stringify(jsonBody),
      options: {
        raw: {
          language: 'json'
        }
      }
    };
    responseNode.body.push(body);
    responseNode.header.push({
      key: 'Content-Type',
      value: 'application/json'
    });

    const result = await processResponse(responseNode);

    Object.keys(jsonBody).forEach(key => {
      const variableName = `{{res_${key}}}`;
      expect(result.body[0].raw).toContain(variableName);
      expect(addVariable).toHaveBeenCalledWith(variableName);
    });
  });
});
