// Test generated by RoostGPT for test nodeJsTest1 using AI Type Azure Open AI and AI Model roost-gpt4-32k

import { parsePostmanCollection } from "./postmanCollectionProcessor.js";

describe('parsePostmanCollection', () => {
  let node = null;
  let swaggerContent = {};

  beforeEach(() => {
    node = { header: [{ key: "Content-Type", value: "value" }] };
    swaggerContent = {};
  });

  test('should process headers', async () => {
    const result = await parsePostmanCollection(node, swaggerContent);
    
    expect(result.header[0].value).toBe(`{{Content-Type}}`);
  });

  test('should not process exempt headers', async () => {
    node.header[0].key = "Accept";
    const result = await parsePostmanCollection(node, swaggerContent);

    expect(result.header[0].value).toBe('value');
  });

  test('should process url variables', async () => {
    node.url = { variable: [{ key: "urlVariable", value: "value" }] };
    const result = await parsePostmanCollection(node, swaggerContent);

    expect(result.url.variable[0].value).toBe(`{{urlVariable}}`);
  });

  test('should process form data', async () => {
    node.body = { mode: 'formdata', formdata: [{ key: "formdataVariable", value: "value" }] };
    const result = await parsePostmanCollection(node, swaggerContent);

    expect(result.body.formdata[0].value).toBe(`{{formdataVariable}}`);
  });

  test('should process urlencoded values', async () => {
    node.body = { mode: 'urlencoded', urlencoded: [{ key: "urlEncodedVar", value: "value" }] };
    const result = await parsePostmanCollection(node, swaggerContent);

    expect(result.body.urlencoded[0].value).toBe(`{{urlEncodedVar}}`);
  });

  test('should not process invalid body mode', async () => {
    node.body = { mode: 'invalid', formdata: [{ key: "formdataVariable", value: "value" }] };
    const result = await parsePostmanCollection(node, swaggerContent);

    expect(result.body.formdata[0].value).toBe("value");
  });

  test('should return error on invalid json body', async () => {
    node.body = { mode: 'raw', raw: "{ invalidJson:", options: { raw: { language: 'json' } } };
    node.header = [{ key: "Content-Type", value: "application/json" }];
    try {
      await parsePostmanCollection(node, swaggerContent);
    } catch (error) {
      expect(error.message).toEqual("Unexpected end of JSON input");
    }
  });
});
